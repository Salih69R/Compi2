%{
	#include <stdio.h>
	#include <iostream>
	#include "structs.hpp"
	

	
	int yylex();
	void yyerror(const char*);
	extern int yylineno;
	
	using namespace std;
	
	Symbol_Table symbolTable = Symbol_Table();
	Function* curFunc;
	stack<vector<Node*>> ParamListStack = stack<vector<Node*>>();
	

%}




%token  VOID INT BYTE B BOOL ENUM TRUE FALSE RETURN ELSE WHILE BREAK CONTINUE SC COMMA LBRACE RBRACE ID NUM STRING
%right ASSIGN
%left OR
%left AND
%left EQUALOP
%left RELATIONOP
%left ADDOPS
%left MULTOPS
%right LPAREN RPAREN
%right IF ELSE
%right NOT


%%

Program : 		Enums Funcs 										
						{};


Funcs :			/*epsilon*/ 													
						{}
				| FuncDecl Funcs 													
						{};



FuncDecl :		RetType ID  {
							if(symbolTable.getVar($2->name)){
								errorDef(yylineno, $2->name);
								delete $1;
								delete $2;
								exit(0);
							}
							curFunc = new Function($2->name,$1->type);
							$2->type = FUNCTION_t;
						} LPAREN Formals RPAREN LBRACE 
						{symbolTable.insertFunc(curFunc);}
						Statements RBRACE 
						{symbolTable.closeScope();
							delete $1;
							delete $2;
							delete curFunc;
							}
						;

Enums :			/*epsilon*/ 															
						{}
				| EnumDecl Enums 													
						{};

EnumDecl :		ENUM ID LBRACE EnumeratorList RBRACE SC 					
						{};

RetType :		Type 														
						{$$ = $1;}
				| VOID 																
						{$$ = new Node(VOID_t);};

Formals :		/*epsilon*/ 												
						{}
				| FormalsList 														
						{};

FormalsList :	FormalDecl 													
						{}
				| FormalDecl COMMA FormalsList 									
						{};

FormalDecl :	Type ID 													
						{
							curFunc->addParam(new Variable($1->type,$2->name));
							$2->type = $1->type;
						}
				| EnumType ID 														
						{};


EnumeratorList :	Enumerator 											
						{}
				| EnumeratorList COMMA Enumerator 									
						{};

Enumerator :		ID 															
						{};

Statements :	Statement 													
						{}
				| Statements Statement 												
						{};

Statement :		LBRACE {
					symbolTable.openScope(NORMAL);
				} Statements RBRACE {
					symbolTable.closeScope();
						}
				| Type ID SC 														

						{
							Variable* var = symbolTable.getVar($2->name);
							if(var != nullptr){
								errorDef(yylineno, $2->name);
								delete $1;
								delete $2;
								exit(0);
							}
							var = new Variable($1->type,$2->name);
							symbolTable.insertVar(var);

							delete $1;
							delete $2;
						}
				| EnumType ID SC 													
						{}
				| EnumDecl 															
		
						{}
				| Type ID ASSIGN Exp SC 											
						{
							Variable* var = symbolTable.getVar($2->name);
							if(var != nullptr){
								errorDef(yylineno, $2->name);
								delete $1;
								delete $2;
								delete $4;
								exit(0);
							}
							var = new Variable($1->type,$2->name);
							var->value = $4->value;


							symbolTable.insertVar(var);
							delete $1;
							delete $2;
							delete $4;
							}
				| EnumType ID ASSIGN Exp SC 										
						{}
				| ID ASSIGN Exp SC 													
						{
							Variable* var = symbolTable.getVar($1->name);
							if(var == nullptr ){
								errorDef(yylineno, $2->name);
								delete $1;
								delete $3;
								exit(0);
							}
							if((var->type != $3->type) && (var->type != INT_t && $3->type != BYTE_t)){
								errorMismatch(yylineno);
								delete $1;
								delete $3;
								exit(0);
							}
							var->value = $3->value;

							delete $1;
							delete $3;
						}
				| Call SC 															
						{}
				| RETURN SC 														
						{
							auto& scope = symbolTable.scopes_table[symbolTable.scopes_table.size()-1];
							assert(scope.curFunc != nullptr);//grammar makes sure
							auto f = scope.curFunc;
							if(f->returnType != VOID_t){
								errorMismatch(yylineno);
								exit(0);
							}
						}
				| RETURN Exp SC 													
						{
							auto& scope = symbolTable.scopes_table[symbolTable.scopes_table.size()-1];
							assert(scope.curFunc != nullptr);//grammar makes sure
							auto f = scope.curFunc;
							if(f->returnType != $2->type && (f->returnType != INT_t && $2->type != BYTE_t) ){
								errorMismatch(yylineno);
								delete $2;
								exit(0);
							}
						}
				| IF LPAREN checkBoolExp RPAREN Statement 									
						{
						}
				| IF LPAREN checkBoolExp  RPAREN Statement ELSE Statement 	
						{}
				| WHILE LPAREN checkBoolExp 
				{
					 symbolTable.openScope(LOOP);
				} RPAREN  Statement 									
						{
							symbolTable.closeScope();
						 }
				| BREAK SC 															
						{
							auto& scope = symbolTable.scopes_table[symbolTable.scopes_table.size()-1];
							if(!scope.isLoop){
								errorUnexpectedBreak(yylineno);
								exit(0);
							}
						}
				| CONTINUE SC 														
						{
							auto& scope = symbolTable.scopes_table[symbolTable.scopes_table.size()-1];
							if(!scope.isLoop){
								errorUnexpectedContinue(yylineno);
								exit(0);
							}
						};
checkBoolExp :     Exp {
						if($1->type != BOOL_t)
						{
							errorMismatch(yylineno);
							delete $1;
							exit(0);
						}
					}
Call :			ID LPAREN {ParamListStack.push(vector<Node*>()); } ExpList RPAREN 										
						{
							Function* callee = (Function*)symbolTable.getVar($1->name);
							auto& vec = ParamListStack.top();

							if (callee == nullptr || callee->type != FUNCTION_t){
								delete $1;
								errorUndefFunc(yylineno, $1->name);
								
								for(int i = 0; i< vec.size() ; ++i)
									delete vec[i];
								
								ParamListStack.pop();
								exit(0);
							}
							delete $1;
							callee->ValidateParameters(vec);
							$$ = new Node(callee->returnType);

							for(int i = 0; i< vec.size() ; ++i)
								delete vec[i];	
							ParamListStack.pop();

						}

				| ID LPAREN RPAREN 													
						{
							Function* callee = (Function*)symbolTable.getVar($1->name);
							if (callee == nullptr || callee->type != FUNCTION_t){
								delete $1;
								errorUndefFunc(yylineno, $1->name);
								exit(0);
							}
							delete $1;
							//check about the delete here 
							auto tmp = vector<Node*>();
							callee->ValidateParameters(tmp);
							$$ = new Node(callee->returnType);

						};

ExpList :		Exp 														
						{ParamListStack.top().push_back($1);}
				| Exp COMMA ExpList 												
						{ParamListStack.top().push_back($1);};

Type :			INT 															
						{$$ = new Node(INT_t);}
				| BYTE 																
						{$$ = new Node(BYTE_t);}
				| BOOL 																
						{$$ = new Node(BOOL_t);};

EnumType :		ENUM ID 													
						{};
						

Exp :			LPAREN Exp RPAREN 											
						{$$ = $2;}

				| Exp ADDOPS Exp 													
						{ if (($1->type != INT_t && $1->type !=BYTE_t) || ($3->type != INT_t && $3->type != BYTE_t)){
							errorMismatch(yylineno);
							delete $1;
							delete $3;
							exit(0);
						}
						if ($1->type == BYTE_t && $3->type == BYTE_t){
							delete $1;
							delete $3;
							$$ = new Node(BYTE_t);
						}
						else{ 
							$$= new Node(INT_t);
							delete $1;
							delete $3;
							}

						}
				| Exp MULTOPS Exp 													
						{ if (($1->type != INT_t && $1->type !=BYTE_t) || ($3->type != INT_t && $3->type != BYTE_t)){
							errorMismatch(yylineno);
							delete $1;
							delete $3;
							exit(0);
						}
						if ($1->type == BYTE_t && $3->type == BYTE_t){
							delete $1;
							delete $3;
							$$ = new Node(BYTE_t);
						}
						else{ 
							$$= new Node(INT_t);
							delete $1;
							delete $3;
							}

						}

				| ID 																
					{ Variable* var = symbolTable.getVar($1->name);
							if(var == nullptr){
								errorDef(yylineno, $1->name);
								delete $1;
								exit(0);
							}
						$$ = new Variable($1->type,$1->name);
						delete $1;
					}

				| Call 																
					{
						if($1->type == VOID_t){
							errorMismatch(yylineno);
							exit(0);
						}
						$$ = $1;
					}

				| NUM 																
						{	$$ = new Node(NUM_t , "" , $1->value);
							delete $1;
						}

				| NUM B 														
					{	if( !( stoi($1->value) >= 0 && (stoi($1->value) <= 255))){
										
											errorByteTooLarge(yylineno, $1->value);
											delete $1;
											exit(0);
										}
						$$ = new Node(BYTE_t,"",$1->value);
						delete $1;

					}

				| STRING 															
						{$$ = new Node(STRING_t);}

				| TRUE 																
						{$$ = new Node(BOOL_t);}

				| FALSE 															
						{$$ = new Node(BOOL_t);}
						
				| NOT Exp 															
						{
							if($2->type != BOOL_t){
									errorMismatch(yylineno);
									delete $2;
									exit(0);
							}
							//check about the names , if all of the are "" and we created empty var , or var with name identifed such as numm,
							$$ = new Node(BOOL_t);
							delete $2;
						}


				| Exp AND Exp 														
						{
							if($1->type != BOOL_t || $3->type != BOOL_t){
									errorMismatch(yylineno);
									delete $1;
									delete $3;
									exit(0);
							}
							$$ = new Node(BOOL_t);
							delete $1;
							delete $3;

						}

				| Exp OR Exp 														
						{
							if($1->type != BOOL_t || $3->type != BOOL_t){
									errorMismatch(yylineno);
									delete $1;
									delete $3;
									exit(0);
							}
							$$ = new Node(BOOL_t);
							delete $1;
							delete $3;
						}

				| Exp RELATIONOP Exp 												
						{
							if(($1->type != INT_t && $1->type != BYTE_t) || ($3->type != INT_t && $3->type != BYTE_t)){
									errorMismatch(yylineno);
									delete $1;
									delete $3;
									exit(0);
							}
							$$ = new Node(BOOL_t);
							delete $1;
							delete $3;
						}

				| Exp EQUALOP Exp 													
						{
							if(($1->type != INT_t && $1->type != BYTE_t) || ($3->type != INT_t && $3->type != BYTE_t)){
									errorMismatch(yylineno);
									delete $1;
									delete $3;
									exit(0);
							}
							$$ = new Node(BOOL_t);
							delete $1;
							delete $3;
						}

				| LPAREN Type RPAREN Exp 											
						{
							//enums we should save thier number so cast is available and the max number
							//check if the variable exsists.

						};


%%



int main()
{

	yyparse();
	Function* main_func = (Function*)symbolTable.getVar("main");
	if (main_func == nullptr || main_func->type != FUNCTION_t || main_func->paramTypes.size()!= 0 || main_func->returnType != VOID_t){
		errorMainMissing();
		return 0;
	}


    return 0;
}

void yyerror(char const* error){
	errorSyn(yylineno);
	exit(0);
}




