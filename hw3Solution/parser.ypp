%{
	#include <stdio.h>
	#include <iostream>
	#include "structs.hpp"
	

	
	int yylex();
	void yyerror(const char*);
	extern int yylineno;
	
	using namespace std;

	
	

%}




%token  VOID INT BYTE B BOOL ENUM TRUE FALSE RETURN ELSE WHILE BREAK CONTINUE SC COMMA LBRACE RBRACE ID NUM STRING
%right ASSIGN
%left OR
%left AND
%left EQUALOP
%left RELATIONOP
%left ADDOPS
%left MULTOPS
%right LPAREN RPAREN
%right IF ELSE
%right NOT


%%

Program : 		Enums Funcs 										
						{};


Funcs :			/*epsilon*/ 													
						{}
				| FuncDecl Funcs 													
						{};



FuncDecl :		RetType ID LPAREN Formals RPAREN LBRACE Statements RBRACE 	
						{};

Enums :			/*epsilon*/ 															
						{}
				| EnumDecl Enums 													
						{};

EnumDecl :		ENUM ID LBRACE EnumeratorList RBRACE SC 					
						{};

RetType :		Type 														
						{}
				| VOID 																
						{};

Formals :		/*epsilon*/ 												
						{}
				| FormalsList 														
						{};

FormalsList :	FormalDecl 													
						{}
				| FormalDecl COMMA FormalsList 									
						{};

FormalDecl :	Type ID 													
						{}
				| EnumType ID 														
						{};


EnumeratorList :	Enumerator 											
						{}
				| EnumeratorList COMMA Enumerator 									
						{};

Enumerator :		ID 															
						{};

Statements :	Statement 													
						{}
				| Statements Statement 												
						{};

Statement :		LBRACE Statements RBRACE 									
						{}
				| Type ID SC 														

						{}
				| EnumType ID SC 													
						{}
				| EnumDecl 															
		
						{}
				| Type ID ASSIGN Exp SC 											
						{}
				| EnumType ID ASSIGN Exp SC 										
						{}
				| ID ASSIGN Exp SC 													
		
						{}
				| Call SC 															
						{}
				| RETURN SC 														
						{}
				| RETURN Exp SC 													
						{}
				| IF LPAREN Exp RPAREN Statement 									
						{}
				| IF LPAREN Exp RPAREN Statement ELSE Statement 						
		
						{}
				| WHILE LPAREN Exp RPAREN Statement 									
						{}
				| BREAK SC 															
						{}
				| CONTINUE SC 														
						{};

Call :			ID LPAREN ExpList RPAREN 										
						{}
				| ID LPAREN RPAREN 													
						{};

ExpList :		Exp 														
						{}
				| Exp COMMA ExpList 												
						{};

Type :			INT 															
						{}
				| BYTE 																
						{}
				| BOOL 																
						{};

EnumType :		ENUM ID 													
						{};
						

Exp :			LPAREN Exp RPAREN 											
						
						{ 
							$$ = $2;
							delete $1;
							delete $3;
						 }
				| Exp ADDOPS Exp 													
						
						{
							if($1->type != INT_t || $2->type != INT_t){
								//TODO: implement error
							}
							$$ = new EXP_T();
							$$->type = INT_t;
							if($2->op == "+")
							{
								$$->value = std::to_string( stoi($1->value) + stoi($3->value) );
							}
							//else $2->op is "-"

							$$->value = std::to_string( stoi($1->value) - stoi($3->value) );
							delete $1;
							delete $2;
							delete $3;
						}
				| Exp MULTOPS Exp 													
						{
							if($1->type != INT_t || $2->type != INT_t){
								//TODO: implement error
							}
							$$ = new EXP_T();
							$$->type = INT_t;
							if($2->op == "*")
							{
								$$->value = std::to_string( stoi($1->value) * stoi($3->value) );
							}
							//else $2->op is "/"

							$$->value = std::to_string( stoi($1->value) / stoi($3->value) );
							delete $1;
							delete $2;
							delete $3;
						}

				| ID 																
						{	
							$$ = new EXP_T();
							$$->value = $1->value;
							$$->type = $1->type;
							delete $1;
						}

				| Call 																
						{
							$$ = new EXP_T();
							$$->value = $1->value;
							$$->type = $1->type;
							delete $1;
						}

				| NUM 																
						{
							$$ = new EXP_T();
							$$->value = $1->value;
							$$->type = INT_t;
							delete $1;
						}

				| NUM B //what??															
						{}

				| STRING 															
						{
							$$ = new EXP_T();
							$$->value = $1->value;
							$$->type = STRING_t;
							delete $1;
						}

				| TRUE 																
						{
							$$ = new EXP_T();
							$$->value = "true";
							$$->type = BOOL_t;
							delete $1;
						}

				| FALSE 															
						{
							$$ = new EXP_T();
							$$->value = "false";
							$$->type = BOOL_t;
							delete $1;
						}
						
				| NOT Exp 															
						{
							if($2->type != BOOL_t){
								//TODO: implement error
							}
							$$ = $2;
							if($$->value == "true")
								$$->value = "false";
							else
								$$->value = "true";

								delete $1;

						}


				| Exp AND Exp 														
						{
							if($1->type != BOOL_t || $3->type!=BOOL_t){
								//TODO: implement error
							}
							$$ = new EXP_T();
							$$->type = BOOL_t;
							if($1->value == "true" && $3->value=="true")
								$$->value = "true";
							else
								$$->value = "false";

							delete $1;
							delete $2;
							delete $3;
						}

				| Exp OR Exp 														
						{
							if($1->type != BOOL_t || $3->type!=BOOL_t){
								//TODO: implement error
							}
							$$ = new EXP_T();
							$$->type = BOOL_t;

							if($1->value == "true" || $3->value=="true")
								$$->value = "true";
							else
								$$->value = "false";

							delete $1;
							delete $2;
							delete $3;
						}

				| Exp RELATIONOP Exp 												
						{
							if($1->type !=  $3->type){
								//TODO: implement error
							}
							$$ = new EXP_T();
							$$->type = BOOL_t;
					
							if($2->op == "<=")
							{
								if(stoi($1->value) <= (stoi($3->value))  )
									$$->value = "true";
								else 
									$$->value = "false";
							}
							if($2->op == "<")
							{
								if(stoi($1->value) < (stoi($3->value))  )
									$$->value = "true";
								else 
									$$->value = "false";
							}
							if($2->op == ">=")
							{
								if(stoi($1->value) >= (stoi($3->value))  )
									$$->value = "true";
								else 
									$$->value = "false";
							}
							if($2->op == ">")
							{
								if(stoi($1->value) > (stoi($3->value))  )
									$$->value = "true";
								else 
									$$->value = "false";
							}
							delete $1;
							delete $2;
							delete $3;
						}

				| Exp EQUALOP Exp 													
						{
							if($1->type != $3->type)
							{
								//TODO: implement error
								//TODO: check if type is VOID_t and check if it needs to be an error
							}
							$$ = new EXP_T();
							$$->type = BOOL_t;
							if($2->op == "==")
							{
								if($1->value == $3->value)
									$$->value = "true";
								else
									$$->value = "false";
							}

							//2->op is !=

							if($1->value != $3->value)
								$$->value = "true";
							else
								$$->value = "false";

							delete $1;
							delete $2;
							delete $3;
						}

				| LPAREN Type RPAREN Exp 											
						{
							//TODO: implement after understanding this better

						};


%%



int main()
{
    return yyparse();
}

void yyerror(char const* error){
//	errorSyn(yylineno);
	exit(0);
}


